/-
Copyright (c) 2024 Stephan Maier. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Stephan Maier
-/
import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Image
import Mathlib.LinearAlgebra.AffineSpace.Basic
import Mathlib.LinearAlgebra.AffineSpace.AffineMap
import Mathlib.Topology.Algebra.ContinuousAffineMap
import Mathlib.Algebra.BigOperators.Finprod
import Mathlib.Algebra.AddTorsor
import Mathlib.Algebra.Module.Basic
import Mathlib.Topology.Defs.Basic
import Mathlib.Topology.Defs.Induced
import Mathlib.Topology.ContinuousFunction.Basic
import Mathlib.Topology.Homeomorph
import Mathlib.Topology.Algebra.Ring.Basic
import Mathlib.Topology.Algebra.Module.Basic
import Mathlib.Topology.Algebra.Affine
import Mathlib.Topology.Algebra.ContinuousAffineMap
import Mathlib.Topology.Algebra.MulAction
import Mathlib.Topology.Order.Basic
import Mathlib.Topology.Order.OrderClosed
import Mathlib.Analysis.Normed.Field.Basic
import Mathlib.Analysis.Normed.Group.AddTorsor

import X2lib.Topology.PiecewiseLinear.Aux.Set
import X2lib.Topology.PiecewiseLinear.Aux.Topology
import X2lib.Topology.PiecewiseLinear.Aux.Affine
import X2lib.Topology.PiecewiseLinear.Aux.Module
import X2lib.Topology.PiecewiseLinear.AffineCone
import X2lib.Topology.PiecewiseLinear.AffineConeNhd

/-!
# Affine polyhedra

Affine polyhedra are introduces as sets in an ambient affine space
whose topology is determined by affine cone-neighbourhoods.

The only assumptions we make on the objects that go into the
definitions are the following:

- The affine space is defined over a field.
- The affine space is a topological space, and so are  the
  underlying field and vector space.
- All actions are continuous.

The resulting theory of affine polyhedra is thus more general than
the theory that is usually explained in the standrad references where
affine polyhedra are usually defined in finite dimensional
real space, and sets that go into definition often are assumed
to be (locally) compact, e.g. the base of cone-neighbourhoods.

In order to acheieve the same results as the standard references
we have to make assumtions on the ambient affine space. These spaces
will be assumed to be polyhedra themselves, compensating for the fact
that a priori an affine space has no polhedral structure to start
with. Compare this to the situation if (infinite dimensional)
topological vector spaces where assumption on the neighbourhood filter
of zero are necessary in order to generate useful topologies.

## Definitions

- `TODO`: ...

## References

See [Rourke-Sanderson] for the basic definitions.
-/

--[FiniteDimensional 𝕜 V]

universe u v w v' w'
open Set
open Filter
open Topology
open BigOperators

-- ********************************************************************
section «Definition»

/-!
## Affine polyhedra

An affine polyhdron set is a subset of an affine space whose relative
topology is induced by (the carrier interiors of) cone-neighbourhoods.
Polyhedra are locally closed subsets of the ambient affine space.

In order to keep notation separate, we introduce `ConeNhdTopology` as
the defining property of poloyhedra, but define `Polyhedron` simply as
a restatement of `ConeNhdTopology`.

As we develop PL-topology in a more general setting than finite dimensional
real space, we also must place conditions on the topology of the ambient
affine space (comparable to what is done for infinite dimensional vector
spaces in functional analysis). These ambient affine spaces must carry
a topology which makes these spaces polyhedra themselves. Thus a
`PolyhedralSpace` is an affine space that carries the `ConeNhdTopology`.

We will below refine the notion of `ConeNhd` and `PolyhedralSpace` in order
to ensure that cone-neighbourhoods and polyhedral spaces allow us to
to pass to boundaries of sets like a `ConeNhd` and still get polyhedra.
-/



variable (𝕜 : Type u) [LinearOrderedField 𝕜] [TopologicalSpace 𝕜] [TopologicalRing 𝕜] [OrderTopology 𝕜]
variable {V : Type v} [AddCommGroup V] [Module 𝕜 V] [TopologicalSpace V] [TopologicalAddGroup V] [ContinuousSMul 𝕜 V]
variable (P : Type w) [AddTorsor V P] [hTopP : TopologicalSpace P] [hTopAddTorsor : TopologicalAddTorsor V P]

namespace Affine

/-- A cone-neighbourhood topology is generated by the interiors of
cone-neighbourhoods. -/
class ConeNhdTopology (s : Set P) : Prop where
  /-- The topology is generated by interior carriers of cone-neighbourhoods. -/
  topology_is_generated_by_cone_nhds :
    -- The relative topology on s
    TopologicalSpace.induced (Subtype.val : s → P) hTopP =
      -- The topology induced by the carrier's interiors of cone-neighbourhoods
      TopologicalSpace.generateFrom { n : Set s | ∃ cn : ConeNhd 𝕜 V P s, n = cn.carrier_interior }
  /-- The set is locally closed in the ambient affine space. -/
  is_locally_closed : IsLocallyClosed s

/-- An affine polyhedron is a set in an ambient affine space which carries
the `ConeNhdTopology`. This only restates `ConeNhdTopology`. -/
def Polyhedron (s : Set P) := ConeNhdTopology 𝕜 P s

/-- A polyhedral space is an affine space whose universal set carries the
polyhedral topology. -/
class PolyhedralSpace : Prop where
  carries_ConeNhdTopology : ConeNhdTopology 𝕜 P (Set.univ)

end Affine

end «Definition»

-- ********************************************************************
section «Star-neighbourhood»

-- --------------------------------------------------------------------
section «Definition»

/-!
## Star neighbourhoods

An affine star-neighbourhood is an affine cone-neighbourhood whose base
is a polyhedron. This particular kind of cone-neighbourhood will be the
essential building-block for PL-topology. It will be shown that the
topology of a polyhedron is generated by star-neighbourhoods which allows
us, when doing topological arguments, to work entirely within the category
of polyhedra. -/

variable (𝕜 : Type u) [LinearOrderedField 𝕜] [TopologicalSpace 𝕜] [TopologicalRing 𝕜] [OrderTopology 𝕜]
variable {V : Type v} [AddCommGroup V] [Module 𝕜 V] [TopologicalSpace V] [TopologicalAddGroup V] [ContinuousSMul 𝕜 V]
variable (P : Type w) [AddTorsor V P] [hTopP : TopologicalSpace P] [hTopAddTorsor : TopologicalAddTorsor V P]

namespace Affine

/-- An affine star-neighbourhood is an affine cone-neighbourhood whose
base is a polyhedron. -/
class StarNhd (s : Set P) extends ConeNhd 𝕜 V P s where
  /-- The base of a star-neighbourhood is a polyhedron.-/
  base_is_polyhedron : Polyhedron 𝕜 P base

/-- This allows us to view a `StarNhd` as a `ConeNhd`.-/
instance CoeSort_StarNhd_to_ConeNhd : CoeSort (StarNhd 𝕜 P s) (ConeNhd 𝕜 V P s) where
  coe sn := sn.toConeNhd

/-- A star-topology is generated by by the interiors of star-neighbourhoods. -/
class StarNhdTopology (s : Set P) : Prop where
  /-- The topology is generated by interior carriers of star-neighbourhoods. -/
  topology_is_generated_by_star_nhds :
    -- The relative topology on s
    TopologicalSpace.induced (Subtype.val : s → P) hTopP =
      -- The topology induced by the carrier's interiors of star-neighbourhoods
      TopologicalSpace.generateFrom { n : Set s | ∃ cn : StarNhd 𝕜 P s, n = cn.carrier_interior }
  /-- The set is locally closed in the ambient affine space. -/
  is_locally_closed : IsLocallyClosed s

/-- A star-neighbourhood (topology) space is an affine space whose
universal set carries the star-neighbourhood topology. We will require
that the ambient affine spaces that we work with are starred spaces in
order to ensure that the ambient topology is generated by star-neighbourhoods. -/
class PLSpace : Prop where
  carries_StarNhdTopology : StarNhdTopology 𝕜 P (Set.univ)

end Affine

end «Definition»

-- --------------------------------------------------------------------
section «Equality»

/-!
### Equality of star-neighbourhoods
-/

variable {𝕜 : Type u} [LinearOrderedField 𝕜]
variable {V : Type v} [AddCommGroup V] [Module 𝕜 V]
variable {P : Type w} [AddTorsor V P] [topologyP : TopologicalSpace P]

open Affine.Cone
open Affine.ConeNhd

namespace Affine.StarNhd

/-- Two star-neighbourhoods are equal iff their vertices and bases are equal. -/
theorem eq (sn sn' : StarNhd 𝕜 P s) : sn = sn' ↔ sn.vertex = sn'.vertex ∧ sn.base = sn'.base := by
  constructor
  · intro h; rw [h]; simp
  · rintro h
    have hceq : sn.toConeNhd = sn'.toConeNhd := (sn.toConeNhd.eq sn'.toConeNhd).mpr h
    calc
      sn = ⟨ sn.toConeNhd, sn.base_is_polyhedron ⟩ := rfl
      _  = ⟨ sn'.toConeNhd, sn'.base_is_polyhedron ⟩ := by
           simp only [hceq]
      _ = sn' := rfl

end Affine.StarNhd

end «Equality»

-- --------------------------------------------------------------------
section «Topology»

/-!
### Topology defined by star-neighbourhoods
-/

variable {𝕜 : Type u} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜] [TopologicalRing 𝕜] [OrderTopology 𝕜]
variable {V : Type v} [AddCommGroup V] [Module 𝕜 V] [TopologicalSpace V] [TopologicalAddGroup V] [ContinuousSMul 𝕜 V]
variable {P : Type w} [AddTorsor V P] [topologyP : TopologicalSpace P] [hTopAddTorsor : TopologicalAddTorsor V P]

open Affine.Cone
open Affine.ConeNhd

namespace Affine.StarNhd

/-- Given a `StarNhdTopology` this defines the implied `ConeNhdTopology`. -/
def StarNhdTopology_to_ConeNhdTopology (s : Set P) (snhdTop : StarNhdTopology 𝕜 P s) : ConeNhdTopology 𝕜 P s where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := snhdTop.is_locally_closed

/-- This allows us to view a `StarNhdTopology` as a `ConeNhdTopology`.-/
instance CoeSort_StarNhdTopology_to_ConeNhdTopology : CoeSort (StarNhdTopology 𝕜 P s) (ConeNhdTopology 𝕜 P s) where
  coe sn := StarNhdTopology_to_ConeNhdTopology s sn

/-- Given a `PLSpace` this defines the implied `PolyhedralSpace`. -/
def PLSpace_to_PolyhedralSpace (pl : PLSpace 𝕜 P) : PolyhedralSpace 𝕜 P where
  carries_ConeNhdTopology := pl.carries_StarNhdTopology

/-- This allows us to view a `PLSpace` as a `PolyhedralSpace`.-/
instance CoeSort_PLSpace_to_PolyhedralSpace : CoeSort (PLSpace 𝕜 P) (PolyhedralSpace 𝕜 P) where
  coe pl := PLSpace_to_PolyhedralSpace pl

end Affine.StarNhd

end «Topology»

-- --------------------------------------------------------------------
end «Star-neighbourhood»

-- ********************************************************************
section «Affine polyhedra basics»

/-!
## Basic properties of affine polyhedra
-/

variable {𝕜 : Type u} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜] [TopologicalRing 𝕜] [OrderTopology 𝕜]
variable {V : Type v} [AddCommGroup V] [Module 𝕜 V] [TopologicalSpace V] [TopologicalAddGroup V] [ContinuousSMul 𝕜 V]
variable {P : Type w} [AddTorsor V P] [hTopP : TopologicalSpace P] [hTopAddTorsor : TopologicalAddTorsor V P]

namespace Affine.Polyhedron

-- --------------------------------------------------------------------
/-!
### Sets
-/

/-- The carrier of an affine polyhedral set is the set for which it is defined. -/
@[inline] def carrier (_ : Polyhedron 𝕜 P s) : Set P := s

/-- This allows us to view an `AffinePolyhedron` as a `Set P`.-/
instance CoeSort_to_Set : CoeSort (Polyhedron 𝕜 P s) (Set P) where
  coe := carrier

-- --------------------------------------------------------------------
/-!
### Topology
-/

/-
TODO s locally closed
TODO Hausdorff, normal
TODO something on finite dimensions?
TODO Points closed, locally closed, locally connected, normal. -/

/-- Polyhedral sets carry the induced topology. -/
def topology (_ : Polyhedron 𝕜 P s) : TopologicalSpace s :=
  TopologicalSpace.induced (Subtype.val : s → P) hTopP

/-- This allows us to view the carrier of a `Polyhedron` as
`TopologicalSpace`.-/
instance CoeSort_Polyhedron_carrier_to_TopologicalSpace : CoeSort (Polyhedron 𝕜 P s) (TopologicalSpace s) where
  coe := topology

/-- Given a cone neighbourhood, and given that the ambient space is polyhedral,
there is a cone-neighbourhood in ambient affine space the intersection of the interior
of which with the set lies in the interior of the cone-neighbourhood. -/
theorem carrier_interior_is_nhd__coneNhd_witness [hPolyhedralSpace: Affine.PolyhedralSpace 𝕜 P]
    (cn : ConeNhd 𝕜 V P s) : ∃ cu : ConeNhd 𝕜 V P Set.univ, cu.carrier_interior ∩ s ⊆ cn.carrier_interior := by
  --rcases cn.carrier_interior_is_nhd__witness with ⟨u', ⟨hun', husci'⟩⟩
  --rcases mem_nhds_iff.mp hun' with ⟨u, ⟨huu', ⟨huo, hvu⟩⟩⟩
  --have h1 := hPolyhedralSpace.carries_ConeNhdTopology.topology_is_generated_by_cone_nhds
  --have h2 := is_topological_basis
  --exact mem_nhdsWithin_iff_exists_mem_nhds_inter.mp cn.carrier_interior_is_nhd
  admit

/-- Any neighbourhood of a point in an affine polyhedron contains a cone neighbourhood. -/
theorem nhd_contains_cone_nhd (ap : Polyhedron 𝕜 P s) (hn : n ∈ 𝓝[s] p) :
    ∃ cn : ConeNhd 𝕜 V P s, ↑cn ⊆ n := by
  admit

/-- Points in an affine polyhedron are (relatively) closed. -/
theorem points_closed (ap : Polyhedron 𝕜 P s) (p : s) :
    IsClosed ( { p } : Set s) := by
  admit

end Affine.Polyhedron

end «Affine polyhedra basics»

-- ********************************************************************
section «Constructing polyhedra»

/-!
## Constructing polyhedra from polyhedra

Given polyhedra, new polyhedra can be constructed by operations such
as set-union or set-intersection, join- and cone-constructions. This section
lists the following constructions:

- Open subsets of polyhedra
- Intersection of polyhedra
- Union of polyhedra
- Affine joins of polyhedra
- Affine cones on polyhedra

For other basic examples of polyhedra see

- `Affine.Halfspace`
- `Affine.Cell`

For half spaces see [Lean](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Geometry/Manifold/Instances/Real.html)

-/

/-
TODO Show that everything below also workls for polyhedra with StarNhdTopology -/

variable {𝕜 : Type u} [LinearOrderedField 𝕜]
variable {V : Type v} [AddCommGroup V] [Module 𝕜 V]
variable {P : Type w} [AddTorsor V P] [TopologicalSpace P]
variable {W : Type v'} [AddCommGroup W] [Module 𝕜 W]
variable {Q : Type w'} [AddTorsor W Q] [TopologicalSpace Q]

open Affine

-- --------------------------------------------------------------------
section «Affine spaces»

/-- An affine subspace is a polyhedron. -/
theorem AffineSubspace.is_polyhedron (s : AffineSubspace 𝕜 P) : Polyhedron 𝕜 P s where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    admit

/-- An affine subspace is a polyhedron. -/
theorem IsAffineSubspace.is_polyhedron (hs : IsAffineSubspace 𝕜 P s) : Polyhedron 𝕜 P s := by
  exact AffineSubspace.is_polyhedron (hs : AffineSubspace 𝕜 P)

/-- A linear embedding with closed image of an affine space to another maps polyhedra
to polyhedra. -/
theorem Affine.Polyhedron.embed (py : Polyhedron 𝕜 P s) (f : P →ᴬ[𝕜] Q) (he : Embedding f) (hic : IsClosed $ f '' Set.univ) :
    Polyhedron 𝕜 Q (f '' s) where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    admit

-- This is needed to make the following defintion compile.
attribute [local instance] AffineSubspace.toAddTorsor

/-- An affine polyhedron is an affine polyhedron also in any subspace that
contains the polyhedron as a set. The subspace carries the induced
topology. -/
theorem Affine.Polyhedron.in_subspace {a : AffineSubspace 𝕜 P} (hane : Nonempty a)
    (py : Polyhedron 𝕜 P s) (hsp : s ⊆ a) : Polyhedron 𝕜 ↥a (a.subtype ⁻¹' s) where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    admit

/-- A set which is an affine polyhedron in a closed subspace is a
polyhedron also in the ambient space. -/
theorem Affine.Polyhedron.by_subspace {a : AffineSubspace 𝕜 P} (hane : Nonempty a) (hac: IsClosed (a:Set P))
    {s : Set P} (hsp : s ⊆ a) (pya : Polyhedron 𝕜 ↥a (a.subtype ⁻¹' s)) :
    Polyhedron 𝕜 P s where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    admit

end «Affine spaces»

-- --------------------------------------------------------------------
section «Constructions»

/-- If the ambient affine space is polyhedral then the entire ambient space is an affine polyhedron.
This is trivially true by definition. -/
theorem PolyhedralSpace.univ [hPolyhedralSpace: PolyhedralSpace 𝕜 P] :
    Polyhedron 𝕜 P (Set.univ : Set P) :=
  hPolyhedralSpace.carries_ConeNhdTopology

namespace Affine.Polyhedron

/-- The empty set is a polyhedron. -/
theorem empty : Polyhedron 𝕜 P (∅ : Set P) where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    admit

/-- A singleton is a polyhedron. -/
theorem singleton (p : P) : Polyhedron 𝕜 P { p } where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    admit

/-- Open subsets of affine polyhedra are affine polyhedra. -/
theorem open_subset (py : Polyhedron 𝕜 P s)
    (hs : u ⊆ s) (huo : IsOpen $ rel[s] hs) : Polyhedron 𝕜 P u where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    rcases py.is_locally_closed with ⟨o, c, ho, hc, hi⟩
    rcases (rel_open_iff_inter_with_open hs).mp huo with ⟨o', ho', hpyou'⟩
    use o ∩ o'; use c
    apply And.intro $ IsOpen.inter ho ho'
    apply And.intro hc
    rw [inter_comm, ←inter_assoc]
    nth_rewrite 2 [inter_comm]
    rw [←hi, hpyou']

/-- The intersection of two affine polyhedra is an affine polyhedron. -/
theorem inter (py0 : Polyhedron 𝕜 P s0) (py1 : Polyhedron 𝕜 P s1) :
    Polyhedron 𝕜 P (s0 ∩ s1) where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    admit

/-- The intersection of finitely many affine polyhedra is an affine polyhedron. -/
theorem iInter {ind : Finset ι} (s : ind → Set P) (py : ∀ i : ind, Polyhedron 𝕜 P (s i)) :
    Polyhedron 𝕜 P (⋂ i, s i) := by
  --Fin.induction oder Fin.cases
  admit

/-- The union of two affine polyhedra is an affine polyhedron. Note that
this theorem depends on a ambient affine space being polyhedral The reason
is that there is no way to create a useful union of two cone-neighbourhoods
to create a cone-neighbourhood of the union of the polyhedra. Instead, we
need to use cone-neighbourhoods of the ambient affine space in order to
show existence of cone-neighbourhoods of the set-union of the polyhedra. -/
theorem union [instPolyhedralSpace: Affine.PolyhedralSpace 𝕜 P]
    (py0 : Polyhedron 𝕜 P s0) (py1 : Polyhedron 𝕜 P s1) : Polyhedron 𝕜 P (s0 ∪ s1) where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    admit

/-- The union of finitely many affine polyhedra is an affine polyhedron. -/
theorem iUnion {ind : Finset ι} (s : ind → Set P) (py : ∀ i : ind, Polyhedron 𝕜 P (s i)) :
    Polyhedron 𝕜 P (⋃  i, s i) := by
  --Fin.induction oder Fin.cases
  admit

/-- The product of two affine polyhedra as a polyhedron. -/
theorem prod (py0 : Polyhedron 𝕜 P s0) (py1 : Polyhedron 𝕜 Q s1) :
    Polyhedron 𝕜 (P × Q) (Set.prod s0 s1) where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    admit

end Affine.Polyhedron

end «Constructions»

-- --------------------------------------------------------------------
section «Join and Cone»

/-- The join of two affine polyhedra is an affine polyhedron. -/
theorem Affine.Join.is_polyhedron (j : Join 𝕜 V P) (py0 : Polyhedron 𝕜 P j.side0) (py1 : Polyhedron 𝕜 P j.side1) :
    Polyhedron 𝕜 P j where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    admit

/-- A cone is an affine polyhedron. -/
theorem Affine.Cone.is_polyhedron (c : Cone 𝕜 V P) (pby : Polyhedron 𝕜 P c.base) :
    Polyhedron 𝕜 P c where
  topology_is_generated_by_cone_nhds := by
    admit
  is_locally_closed := by
    admit

end «Join and Cone»

-- --------------------------------------------------------------------
end «Constructing polyhedra»

/-
The obvious triangle induced by `QuotientMap.lift` commutes:
```
     g
  X --→ Z
  |   ↗
f |  / hf.lift g h
  v /
  Y
```
-/
--example : 1 = 1

-- ********************************************************************
section «Star topology for subpolyhedra»

/-!
## Star topology for subpolyhedra

This section shows that a subpolyhedron of a polyhedron that carries a
`StarNhdTopology` automatically carries a `StarNhdTopology`. The
important implication of this is that poylhedra in `PLSpace`s
always carry a `StarNhdTopology`. -/

variable {𝕜 : Type u} [LinearOrderedField 𝕜]
variable {V : Type v} [AddCommGroup V] [Module 𝕜 V]
variable {P : Type w} [AddTorsor V P] [TopologicalSpace P]

namespace Affine.Polyhedron

/-- A sub-polyhedron of a polyhedron that carries a star-topology inherits
a star-topology. -/
theorem subpolyhedron_inherits_star_top (py0 : Polyhedron 𝕜 P s0) (py1 : Polyhedron 𝕜 P s1) (hs : s0 ⊆ s1)
    (hstar : StarNhdTopology 𝕜 P s1) : StarNhdTopology 𝕜 P s0 where
  is_locally_closed := py0.is_locally_closed
  topology_is_generated_by_star_nhds := by
    admit

/-
TODO In star-spaces? Make coe?-/

end Affine.Polyhedron

end «Star topology for subpolyhedra»

-- ********************************************************************
section «Affine spaces with polyhedral or star topology»

/-!
## Affine spaces with polyhedral or star topology

In this section we provide the elementary examples of affine spaces that
are polyhedral spaces or even star spaces. These include

- Normed spaces: `TODO`
- Real spaces: `TODO`
-/

namespace Affine.Polyhedron

-- --------------------------------------------------------------------
section «Basics»

/--
TODO Homeomorphic spaces have same topology type. Use the embed-fct from above -/
example : 1=1 := rfl

end «Basics»

-- --------------------------------------------------------------------
section «Finite dimensional spaces»

variable {𝕜 : Type u} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜]

/-- The 1-dimensional affine space is a PL-space. -/
theorem line_is_plspace : PLSpace 𝕜 𝕜 where
  carries_StarNhdTopology := {
    topology_is_generated_by_star_nhds := by admit
    is_locally_closed := by admit
  }

/--
TODO k^n -/
example : 1=1 := rfl

variable {V : Type v} [AddCommGroup V] [Module 𝕜 V]
variable {P : Type w} [AddTorsor V P] [TopologicalSpace P]

/--
TODO Finite dim: Via prod -/
example : 1=1 := rfl

end «Finite dimensional spaces»

-- --------------------------------------------------------------------
section «Normed space»

variable {𝕜 : Type u} [LinearOrderedField 𝕜] [NormedField 𝕜]
variable {V : Type v} [SeminormedAddCommGroup V] [Module 𝕜 V]
variable {P : Type w} [PseudoMetricSpace P] [NormedAddTorsor V P]

open Affine

/-- A normed affine space is a `Affine.PolyhedralSpace`. -/
theorem NormedAddTorsor.is_polyhedral : PolyhedralSpace 𝕜 P where
  carries_ConeNhdTopology := by
    admit

end «Normed space»

-- --------------------------------------------------------------------
section «Finite dimensional spaces»

/--
TODO Fnite dim -/
example : 1=1 := rfl

end «Finite dimensional spaces»

end Affine.Polyhedron

-- --------------------------------------------------------------------
section «Real space»

/--
TODO Real space -/
example : 1=1 := rfl

end «Real space»

end «Affine spaces with polyhedral or star topology»

-- ********************************************************************
section «Basic polyhedra»

/-!
## Basic affine polyhedra

In this section we provide the basic examples of affine polyhedra. These
will be building blocks in constructing and studying polyhedra.

- Convex sets: `TODO`
- Simplices: `TODO`
- Cubes: `TODO`
-/

variable {𝕜 : Type u} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜] [TopologicalRing 𝕜]
variable {V : Type v} [AddCommGroup V] [Module 𝕜 V] [TopologicalSpace V] [TopologicalAddGroup V] [ContinuousSMul 𝕜 V]
variable {P : Type w} [AddTorsor V P] [topologyP : TopologicalSpace P] [TopologicalAddTorsor V P]

-- --------------------------------------------------------------------
/--
TODO Convex sets -/
example : 1=1 := rfl

-- --------------------------------------------------------------------
namespace Affine.Simplex

/-- The set of weights that, given the vertices of a simplex, define
its carrier. -/
def carrier_weights (𝕜' : Type*) [LinearOrderedField 𝕜'] (n : ℕ) := { w : Fin n → 𝕜' | ∀ i, 0 <= w i  ∧ ∑ i, w i <= 1 }

/-- The carrier of a simplex are all points given by linear
combinations of its vertices. -/
def carrier (as : Affine.Simplex 𝕜 P n) : Set P :=
  { p | ∃ w ∈ carrier_weights 𝕜 n, p = (∑ i, (w i) • (as.points (Fin.addNat i 1) -ᵥ as.points 0)) +ᵥ as.points 0 }

/-- The carrioer of a simplex is independent of the ordering of the
vertices. -/
theorem carrier_independent_of_reindex (as : Affine.Simplex 𝕜 P n) (e : Fin (n + 1) ≃ Fin (m + 1)) :
    as.carrier = (as.reindex e).carrier := by
  admit

end Affine.Simplex

-- --------------------------------------------------------------------

-- Cube
example : 1=1 := rfl

end «Basic polyhedra»

-- ********************************************************************
section «Structure of affine polyhedra»

/-!
## Structure of affine polyhedra

In this section we show that affine polyhedra have a fltering by affine
poylyhedera given by the dimension.
TODO.  -/

variable {𝕜 : Type u} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜] [TopologicalRing 𝕜]
variable {V : Type v} [AddCommGroup V] [Module 𝕜 V] [TopologicalSpace V] [TopologicalAddGroup V] [ContinuousSMul 𝕜 V]
variable {P : Type w} [AddTorsor V P] [topologyP : TopologicalSpace P] [TopologicalAddTorsor V P]
variable [instPolyhedralSpace: Affine.PolyhedralSpace 𝕜 P]

-- --------------------------------------------------------------------
section «Definitions»
/-!
### Definitions
-/

namespace Affine.Polyhedron

/-- An affine polyhedron is locally finite dimensional if each point
is contained in a finite dimensional cone neighbourhood. -/
def LocallyFiniteDimensional (py : Polyhedron 𝕜 P s) : Prop := 1 = 1

/-- An affine polyhedron is  finite dimensional if each point is
contained in a finite dimensional cone neighbourhood, and the
dimensions of these neighbourhoods are bounded. -/
def FiniteDimensional (py : Polyhedron 𝕜 P s) : Prop := 1 = 1

-- Define the filtering by dimension and show that it yields a containment of polyhedra

end Affine.Polyhedron

end «Definitions»

-- --------------------------------------------------------------------

-- ********************************************************************
section «PLSpace»

/-!
## PL-Space


See the theorems in `Mathlib.Algebra.Order.CompleteField`, in particular
`LinearOrderedField.uniqueOrderRingIso`.

TODO.  -/

variable {𝕜 : Type u} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜] [TopologicalRing 𝕜]
variable {V : Type v} [AddCommGroup V] [Module 𝕜 V] [TopologicalSpace V] [TopologicalAddGroup V] [ContinuousSMul 𝕜 V]
variable {P : Type w} [AddTorsor V P] [topologyP : TopologicalSpace P] [TopologicalAddTorsor V P]
variable [instPolyhedralSpace: Affine.PolyhedralSpace 𝕜 P]


-- This is needed to make the following defintion compile.
--attribute [local instance] AffineSubspace.toAddTorsor

def xxx (n : ℕ) : 1 = 0 := by
  obtain ⟨a, ha⟩ : ∃ a, 1 < a := sorry
  admit
  --simpa using

structure PLSpace (P : Type w) extends AddTorsor V P, TopologicalSpace P, TopologicalAddTorsor V P

end «PLSpace»

-- ********************************************************************

-- ********************************************************************
-- Move this into own file
-- ********************************************************************
section «Maps of affine polyhedra»

/-!
## Piecewise linear maps

TODO Move this into own file.  -/

variable {𝕜 : Type u} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜] [TopologicalRing 𝕜] {ndtR : ¬ DiscreteTopology 𝕜}
variable {V : Type v} [AddCommGroup V] [Module 𝕜 V] [TopologicalSpace V] [TopologicalAddGroup V] [ContinuousSMul 𝕜 V]
variable {P : Type w} [AddTorsor V P] [topologyP : TopologicalSpace P] [TopologicalAddTorsor V P]
variable [instPolyhedralSpace: Affine.PolyhedralSpace 𝕜 P]

namespace AffinePLMap

-- Show that the graph is a polyhedron

-- Use this to show that there is a filtering by subpolyhedra such that the map
-- is linear on eaxch piece

end AffinePLMap

end «Maps of affine polyhedra»
