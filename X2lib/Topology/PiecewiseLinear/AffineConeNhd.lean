/-
Copyright (c) 2024 Stephan Maier. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Stephan Maier
-/
import Mathlib

import X2lib.Aux.Set
import X2lib.Aux.Affine
import X2lib.Aux.Module
import X2lib.Aux.Topology
import X2lib.LinearAlgebra.AffineSpace.AffineJoin
import X2lib.LinearAlgebra.AffineSpace.AffineCone

/-!
# Affine cone neighbourhoods

The topology of polhedra is given by neighbourhood-filters that are
generated by affine cones. This section defines these cone-neighbourhoods
via the structure `ConeNhd`.

Cone-neighborhoods are defined for containing sets. A `ConeNhd` in a
containing set is an `Affine.Cone` that lies entirely in the containing
set in which it also is a topological neighbourhood.

Cone neighbourhoods will be used to define polyhedra. They capture the local
structure of polyhedra. This includes the defintion of a notion of tangent
space, and local dimensions of polyhedra.

The following basic assumptions are being made on the background structures:

- The affine space is defined over a field.
- The affine space is a topological space, and so are the
  underlying field and vector space.
- All actions are continuous.

## Definitions and main results

The file contains the following definitions:

- `IsConeNhd`: Defines what it means for an `Affine.Cone` to be a
  cone-neighbourhood.
- `ConeNhd`: Extends `Affine.Cone` to the definition of cone-neighbourhood.

The properties of a cone-neighbourhood are chosen so as to provide
useful local topological information about the containing set.

The result in this file show the extent to which cone-neighbourhoods
locally determine the topology of the containing set.

## References

See [Rourke-Sanderson] for the definitions.
-/

universe u v w
open Set
open Filter
open Topology

section Â«Cone neighbourhoodÂ»

-- ********************************************************************
section Â«DefinitionÂ»

/-!
## Affine cone-neighbourhoods
-/

variable (ğ•œ : Type u) [LinearOrderedField ğ•œ] [TopologicalSpace ğ•œ] [TopologicalRing ğ•œ] [OrderClosedTopology ğ•œ]
variable (V : Type v) [AddCommGroup V] [Module ğ•œ V] [TopologicalSpace V] [ContinuousAdd V] [ContinuousSMul ğ•œ V]
variable (P : Type w) [AddTorsor V P] [TopologicalSpace P] [TopologicalAddTorsor V P]

namespace Affine

/-- This defines what it means for an affine cone to be a cone-neighbourhood
in a containing set: The carrier is a closed set and the the carrier's interior
is a (relative) open set in the containing set.-/
structure IsConeNhd (c : Affine.Cone ğ•œ V P) (s : Set P) : Prop where
  /-- The carrier of the cone neighbourhood is contained in the set `s`. -/
  carrier_subset_of_set : c.carrier âŠ† s
  /-- The carrer of the cone is a closed set. -/
  carrier_is_closed : IsClosed c.carrier
  /-- The carrier's interior is an open set in the relative topology of the set. -/
  carrier_interior_is_rel_open : IsOpen $ rel[s] (subset_trans c.carrier_interior_subset_carrier carrier_subset_of_set)
  /- The carrier's interior and the complement of the carrier are separated. -/

/-- A cone-neighbourhood is an affine cone that satisfies the `IsConeNhd`
properties. This structure will be used to define the APi for working with
cone-neighbourhoods. If you prefer working with the `IsConeNhd`, no worries,
as we provide a coercion below, see `CoeSort_Cone_to_ConeNhd`. -/
structure ConeNhd (s : Set P) extends Cone ğ•œ V P where
  /-- The carrier of the cone neighbourhood is contained in the set `s`. -/
  carrier_subset_of_set : carrier âŠ† s
  /-- The carrer of the cone is a closed set. -/
  carrier_is_closed : IsClosed carrier
  /-- The carrier's interior is an open set in the relative topology of the set. -/
  carrier_interior_is_rel_open : IsOpen $ rel[s] (subset_trans toCone.carrier_interior_subset_carrier carrier_subset_of_set)
  /- The carrier's interior and the complement of the carrier are separated. -/

end Affine

end Â«DefinitionÂ»

-- ********************************************************************
section Â«Cone-neighbourhood basicsÂ»

/-!
## Cone neighbourhood basics
-/

variable {ğ•œ : Type u} [LinearOrderedField ğ•œ] [TopologicalSpace ğ•œ] [TopologicalRing ğ•œ] [OrderClosedTopology ğ•œ]
variable {V : Type v} [AddCommGroup V] [Module ğ•œ V] [TopologicalSpace V] [ContinuousAdd V] [ContinuousSMul ğ•œ V]
variable {P : Type w} [AddTorsor V P] [TopologicalSpace P] [TopologicalAddTorsor V P]

open Affine.Cone

namespace Affine.ConeNhd

/-- This allows us to view a `ConeNhd` as an `AffineCone`.-/
instance CoeSort_ConeNhd_to_AffineCone : CoeSort (ConeNhd ğ•œ V P s) (Cone ğ•œ V P) where
  coe cn := cn.toCone

/-- This allows us to view a `ConeNhd` as a subset of the containing set.-/
instance CoeSort_ConeNhd_to_Subset : CoeSort (ConeNhd ğ•œ V P s) (Set s) where
  coe cn := { x : Subtype s | x.val âˆˆ cn.carrier }

/-- This allows us to view an affine cone that satisfies the `IsConeNhd`
properties as a cone-neighbourhood.-/
instance CoeSort_Cone_to_ConeNhd : CoeSort (IsConeNhd ğ•œ V P c s) (ConeNhd ğ•œ V P s) where
  coe hcnhd := {
    vertex := c.vertex
    base := c.base
    vertex_not_in_base := c.vertex_not_in_base
    lines_intersect_eq_base_points := c.lines_intersect_eq_base_points
    carrier_subset_of_set := by
      simp only [c.carrier_def]
      rw [â†c.segment_points_def, â†c.carrier_def]
      exact hcnhd.carrier_subset_of_set
    carrier_is_closed := by
      simp only [c.carrier_def]
      rw [â†c.segment_points_def, â†c.carrier_def]
      exact hcnhd.carrier_is_closed
    carrier_interior_is_rel_open := by
      simp only [rel_open_iff_inter_with_open]
      rcases (rel_open_iff_inter_with_open $ subset_trans c.carrier_interior_subset_carrier hcnhd.carrier_subset_of_set).mp hcnhd.carrier_interior_is_rel_open with âŸ¨o, âŸ¨hoo, hosâŸ©âŸ©
      use o
      apply And.intro hoo
      rw [hos]
      rw [â†c.segment_points_def]
      exact c.carrier_interior_def
  }

/-- A cone-neighbourhood statisfies the `IsConeNhd` properties. You can
use this to access the properties `IsConeNhd` of a cone-neighbourhood-/
def properties (cn : ConeNhd ğ•œ V P s) : IsConeNhd ğ•œ V P cn s where
  carrier_subset_of_set := cn.carrier_subset_of_set
  carrier_is_closed := cn.carrier_is_closed
  carrier_interior_is_rel_open := cn.carrier_interior_is_rel_open

end Affine.ConeNhd

-- ********************************************************************
section Â«Set relationshipsÂ»

/-!
## Set relationships
-/

variable {ğ•œ : Type u} [LinearOrderedField ğ•œ]
variable {V : Type v} [AddCommGroup V] [Module ğ•œ V]
variable {P : Type w} [AddTorsor V P] [TopologicalSpace P]

open Affine.Cone

namespace Affine.ConeNhd

/-- The vertex of the cone neighbourhood is contained in the set. -/
theorem vertex_in_set (cn : ConeNhd ğ•œ V P s) : cn.vertex âˆˆ s := by
  exact Set.mem_of_subset_of_mem cn.carrier_subset_of_set cn.vertex_in_carrier

/-- The base of the cone neighbourhood is contained in the set. -/
theorem base_subset_of_set (cn : ConeNhd ğ•œ V P s) : cn.base âŠ† s := by
  exact subset_trans cn.base_subset_of_carrier cn.carrier_subset_of_set

/-- The carrier's interior of the cone neighbourhood is contained in the set. -/
theorem carrier_interior_subset_of_set (cn : ConeNhd ğ•œ V P s) : cn.carrier_interior âŠ† s := by
  exact subset_trans cn.carrier_interior_subset_carrier cn.carrier_subset_of_set

end Affine.ConeNhd

end Â«Set relationshipsÂ»

-- ********************************************************************
section Â«EqualityÂ»

/-!
## Equality
-/

variable {ğ•œ : Type u} [LinearOrderedField ğ•œ]
variable {V : Type v} [AddCommGroup V] [Module ğ•œ V]
variable {P : Type w} [AddTorsor V P] [TopologicalSpace P]

open Affine.Cone

namespace Affine.ConeNhd

/-- Two cone-neighbourhoods are equal iff their vertices and bases are equal. -/
theorem eq (cn cn' : ConeNhd ğ•œ V P s) : cn = cn' â†” cn.vertex = cn'.vertex âˆ§ cn.base = cn'.base := by
  constructor
  Â· intro h; rw [h]; simp
  Â· rintro h
    have hceq : cn.toCone = cn'.toCone := (cn.toCone.eq cn'.toCone).mpr h
    calc
      cn = âŸ¨ cn.toCone, cn.carrier_subset_of_set, cn.carrier_is_closed, cn.carrier_interior_is_rel_open âŸ© := rfl
      _  = âŸ¨ cn'.toCone, cn'.carrier_subset_of_set, cn'.carrier_is_closed, cn'.carrier_interior_is_rel_open âŸ© := by
           simp only [hceq]
      _ = cn' := rfl

/-- Given another representation of a set which is provably equal to
the set of a given cone-neighbourhood, the cone-neighbourhood can also
be seen as a cone-neighbourhood of the second set. -/
def to_eq_set (cn : ConeNhd ğ•œ V P s) (hs : s = s') : ConeNhd ğ•œ V P s' where
  vertex := cn.vertex
  base := cn.base
  vertex_not_in_base := cn.vertex_not_in_base
  lines_intersect_eq_base_points := cn.lines_intersect_eq_base_points
  carrier_subset_of_set := by
    rw [â†hs]
    simp only [carrier_def]
    rw [â†cn.segment_points_def, â†cn.carrier_def]
    exact cn.carrier_subset_of_set
  carrier_is_closed := by
    simp only [carrier_def]
    rw [â†cn.segment_points_def, â†cn.carrier_def]
    exact cn.carrier_is_closed
  carrier_interior_is_rel_open := by
    simp only [rel_open_iff_inter_with_open]
    rw [â†hs]
    rcases (rel_open_iff_inter_with_open cn.carrier_interior_subset_of_set).mp cn.carrier_interior_is_rel_open with âŸ¨o, âŸ¨hoo, hosâŸ©âŸ©
    use o
    apply And.intro hoo
    rw [hos]
    rw [â†cn.segment_points_def]
    exact cn.carrier_interior_def

/-- Given a set within the containing set and a a cone neighbourhood in this
set, the cone neighbourhood is a cone neighbourhood in this set, too. -/
def to_subset (cn : ConeNhd ğ•œ V P s) (hos : o âŠ† s) (hcno : â†‘cn âŠ† o) : ConeNhd ğ•œ V P o where
  vertex := cn.vertex
  base := cn.base
  vertex_not_in_base := by exact cn.vertex_not_in_base
  lines_intersect_eq_base_points := by exact cn.lines_intersect_eq_base_points
  carrier_subset_of_set := by
    simp only [carrier_def]; rw [â†cn.segment_points_def, â†cn.carrier_def]
    exact hcno
  carrier_is_closed := by
    simp only [carrier_def]; rw [â†cn.segment_points_def, â†cn.carrier_def]
    exact cn.carrier_is_closed
  carrier_interior_is_rel_open := by
    simp only [rel_open_iff_inter_with_open]
    rcases (rel_open_iff_inter_with_open cn.carrier_interior_subset_of_set).mp cn.carrier_interior_is_rel_open with âŸ¨o', âŸ¨hoo', hos'âŸ©âŸ©
    use o'
    apply And.intro hoo'
    have := congr_arg (fun u => o âˆ© u) hos'; simp at this
    rw [â†Set.inter_assoc, inter_eq_left.mpr hos, inter_eq_right.mpr $ subset_trans cn.carrier_interior_subset_carrier hcno] at this
    rw [â†cn.segment_points_def, â†cn.carrier_interior_def]
    exact this

end Affine.ConeNhd

end Â«EqualityÂ»

-- ********************************************************************
section Â«IntersectionÂ»

/-!
## Intersection of cone-neighbourhoods
-/

variable {ğ•œ : Type u} [LinearOrderedField ğ•œ]
variable {V : Type v} [AddCommGroup V] [Module ğ•œ V] [TopologicalSpace V]
variable {P : Type w} [AddTorsor V P] [TopologicalSpace P] [hTopAddTorsor : TopologicalAddTorsor V P]

open Affine.Cone

namespace Affine.ConeNhd

/-- The intersection of two cone-neighbourhoods is a cone-neighbourhood
of the intersection of the containing sets. -/
theorem inter_is_nhd (cn : ConeNhd ğ•œ V P s) (cn' : ConeNhd ğ•œ V P s') (hv : cn.vertex = cn'.vertex)
    : IsConeNhd ğ•œ V P (cn.inter cn' hv) (s âˆ© s') where
  carrier_subset_of_set := by
    rw [inter_carrier]
    exact inter_subset_inter cn.carrier_subset_of_set cn'.carrier_subset_of_set
  carrier_is_closed := by
    admit
  carrier_interior_is_rel_open := by
    admit

end Affine.ConeNhd

end Â«IntersectionÂ»

-- ********************************************************************
section Â«Maps and continuityÂ»

/-!
## Maps and continuity
-/

variable {ğ•œ : Type u} [LinearOrderedField ğ•œ]
variable {V : Type v} [AddCommGroup V] [Module ğ•œ V] [TopologicalSpace V]
variable {P : Type w} [AddTorsor V P] [TopologicalSpace P] [hTopAddTorsor : TopologicalAddTorsor V P]

open Affine.Cone

namespace Affine.ConeNhd

/-- The segment-line-map is continuous. -/
@[continuity] theorem lineMap_continuous [TopologicalSpace ğ•œ] [ContinuousSMul ğ•œ V] [TopologicalAddGroup V]
    (cn : ConeNhd ğ•œ V P s) (p : P) :
    Continuous $ cn.lineMap p := Affine.lineMap_continuous

/-- The map `vector_to` is continuous. -/
@[continuity] theorem vector_to_continuous (cn : ConeNhd ğ•œ V P s) :
    Continuous cn.vector_to := by
  let f (p : P) := (p, cn.vertex)
  let g (x : P Ã— P) := x.fst -áµ¥ x.snd
  have hcf : Continuous f := Continuous.prod_mk continuous_id (continuous_const)
  have hcg : Continuous g := hTopAddTorsor.continuous_vsub
  have _ : cn.vector_to = g âˆ˜ f := by funext p; simp only [Cone.vector_to, f, g, Function.comp_apply]
  exact Continuous.comp hcg hcf

/-
TODO Relative versions of this
-/

end Affine.ConeNhd

end Â«Maps and continuityÂ»

-- ********************************************************************
section Â«Topological propertiesÂ»

/-!
## Topologogical properties
-/

variable {ğ•œ : Type u} [LinearOrderedField ğ•œ]
variable {V : Type v} [AddCommGroup V] [Module ğ•œ V]
variable {P : Type w} [AddTorsor V P] [TopologicalSpace P]

open Affine.Cone

namespace Affine.ConeNhd

/-- The carrier is relatively closed. -/
theorem carrier_is_rel_closed (cn : ConeNhd ğ•œ V P s) : IsClosed $ rel[s] cn.carrier_subset_of_set :=
  rel_closed_if_closed cn.carrier_subset_of_set cn.carrier_is_closed

 /-- The carrier's interior is relatively open in the carrier. -/
theorem carrier_interior_is_rel_open_in_carrier (cn : ConeNhd ğ•œ V P s) : IsOpen $ rel[cn.carrier] cn.carrier_interior_subset_carrier := by
  -- The proof is pedestrian. Replace with `Topology.induced_compose`.
  rcases (rel_open_iff_inter_with_open cn.carrier_interior_subset_of_set).mp cn.carrier_interior_is_rel_open with âŸ¨o, âŸ¨hoo, hsociâŸ©âŸ©
  rw [rel_open_iff_inter_with_open]
  use o
  apply And.intro hoo
  have := congr_arg (fun u => cn.carrier âˆ© u) hsoci
  simp [â†Set.inter_assoc] at this
  simp only [inter_eq_left.mpr cn.carrier_subset_of_set] at this
  simp only [inter_eq_right.mpr cn.carrier_interior_subset_carrier] at this
  exact this

/-- The complement of the carrier is relatively closed. -/
theorem carrier_complement_is_rel_open (cn : ConeNhd ğ•œ V P s) : IsOpen $ (rel[s] cn.carrier_subset_of_set)á¶œ :=
  isOpen_compl_iff.mpr $ cn.carrier_is_rel_closed

/-- The complement of the carrier'r interior is relatively closed. -/
theorem carrier_interior_complement_is_rel_closed (cn : ConeNhd ğ•œ V P s) : IsClosed $ (rel[s] cn.carrier_interior_subset_of_set)á¶œ := by
  exact isClosed_compl_iff.mpr $ cn.carrier_interior_is_rel_open

/-- The base is a closed set in the ambient affine space. -/
theorem base_is_rel_closed (cn : ConeNhd ğ•œ V P s) : IsClosed $ rel[s] cn.base_subset_of_set := by
  suffices hbc : rel[s] cn.base_subset_of_set = ( (rel[s] cn.carrier_interior_subset_of_set) âˆª (rel[s] cn.carrier_subset_of_set)á¶œ )á¶œ by
    rw [compl_union, compl_compl] at hbc
    have : IsClosed $ (rel[s] cn.carrier_interior_subset_of_set)á¶œ âˆ© (rel[s] cn.carrier_subset_of_set) :=
      IsClosed.inter cn.carrier_interior_complement_is_rel_closed cn.carrier_is_rel_closed
    exact hbc â–¸ this
  rw [rel_set_eq_iff_from_set_eq, from_set_of_rel_set_of_eq_id, from_set_compl_comm, from_set_union_comm]
  rw [compl_union, from_set_of_rel_set_of_eq_id, from_set_compl_comm, from_set_of_rel_set_of_eq_id]
  rw [compl_inter, compl_compl, Set.inter_assoc, union_inter_distrib_right, compl_inter_self]
  rw [inter_eq_left.mpr cn.carrier_subset_of_set, union_empty, cn.carrier_eq_carrier_interior_union_base]
  rw [inter_union_distrib_left, compl_inter_self, empty_union, inter_comm]
  rw [inter_eq_self_of_subset_left (Disjoint.subset_compl_left cn.carrier_interior_disjoint_base)]

/-- The base is a closed set. -/
theorem base_is_closed (cn : ConeNhd ğ•œ V P s) : IsClosed cn.base := by
  rcases (rel_closed_iff_inter_with_closed cn.base_subset_of_set).mp cn.base_is_rel_closed with âŸ¨c, âŸ¨hcc, hcsbâŸ©âŸ©
  have := congr_arg (fun u => cn.carrier âˆ© u) hcsb; simp at this
  rw [â†Set.inter_assoc, inter_eq_left.mpr cn.carrier_subset_of_set, inter_eq_right.mpr cn.base_subset_of_carrier] at this
  rw [â†this]
  exact IsClosed.inter cn.carrier_is_closed hcc

/-- The base of a cone-neighbourhood seperates the carrier's interior from the complement
of the carrier. -/
theorem base_separates_space (cn : ConeNhd ğ•œ V P s) :
    Separates (rel[s] cn.carrier_interior_subset_of_set) (rel[s] cn.base_subset_of_set) (rel[s] cn.carrier_subset_of_set)á¶œ := by
  apply separated_if_triplet_open_open_closed
  exact (rel_set_of_disjoint_comm cn.carrier_interior_subset_of_set cn.base_subset_of_set).mpr cn.carrier_interior_disjoint_base
  rw [disjoint_compl_left_iff_subset, rel_set_of_subset_comm]
  exact cn.base_subset_of_carrier
  rw [disjoint_compl_right_iff_subset, rel_set_of_subset_comm]
  exact cn.carrier_interior_subset_carrier
  exact cn.carrier_interior_is_rel_open
  exact cn.carrier_complement_is_rel_open
  exact cn.base_is_rel_closed

/-- The base of a cone-neighbourhood has empty interior. -/
theorem base_has_empty_interior (cn : ConeNhd ğ•œ V P s) : IsEmpty ( interior $ rel[s] cn.base_subset_of_set ) := by

  admit

/-- The base of a cone-neighbourhood is the frontier of the carrier's interior. -/
theorem base_eq_frontier_carrier_interior (cn : ConeNhd ğ•œ V P s) :
    frontier ( rel[s] cn.carrier_interior_subset_of_set ) = ( rel[s] cn.base_subset_of_set ) := by

  admit

end Affine.ConeNhd

end Â«Topological propertiesÂ»

-- ********************************************************************
section Â«Tangent spacesÂ»

/-!
## Tangent spaces

In this section we show that the notion of `Affine.Cone.spanned_submodule`
is independent of the cone-neighbourhood chosen to compute the submodule.
This serves to show that all other notions such as the `Affine.Cone.spanned_subspace`
or the `Affine.Cone.fan` are well-defined in the sense of being independent
of the choice of cone-neighbourhood.
-/

variable {ğ•œ : Type u} [LinearOrderedField ğ•œ]
variable {V : Type v} [AddCommGroup V] [Module ğ•œ V]
variable {P : Type w} [AddTorsor V P] [TopologicalSpace P]

open Affine.Cone

namespace Affine.ConeNhd

/-- Two cone-neighbourhoods centred on the same vertex generate the same
spanned submodules. -/
theorem cone_nhds_have_same_spanned_submodule (cnhd0 cnhd1 : ConeNhd ğ•œ V P s) (hnhdv : cnhd0.vertex = cnhd1.vertex) :
    cnhd0.spanned_submodule = cnhd1.spanned_submodule := by
  -- It is sufficient to prove that one submodule is subset of the other by symmetry
  suffices hsub : (cn0' cn1' : ConeNhd ğ•œ V P s) â†’ (hv' : cn0'.vertex = cn1'.vertex) â†’
      cn0'.spanned_submodule â‰¤ cn1'.spanned_submodule by
    exact eq_of_le_of_le (hsub cnhd0 cnhd1 hnhdv) (hsub cnhd1 cnhd0 hnhdv.symm)
  intro cn0 cn1 hv
  -- We can reduce to considering base points only
  suffices hbs : âˆ€ b : cn0.base, âˆƒ k : ğ•œ, 0 < k âˆ§ (cn0.lineMap b k) âˆˆ cn1.carrier by
    exact cn0.spanned_submodule_le_spanned_submodule cn1 hv hbs
  -- The rest follows from the continuity and neighbourhood properties
  rintro âŸ¨b, hbâŸ©

  admit

/-- Two cone-neighbourhoods centred on the same vertex generate the same
spanned subspaces. -/
theorem cone_nhds_have_same_spanned_subspace (cnhd0 cnhd1 : ConeNhd ğ•œ V P s) (hnhdv : cnhd0.vertex = cnhd1.vertex) :
    cnhd0.spanned_subspace = cnhd1.spanned_subspace :=
  (cnhd0.spanned_submodule_eq_iff_spanned_subspace_eq cnhd1 hnhdv).mp $
    cnhd0.cone_nhds_have_same_spanned_submodule cnhd1 hnhdv

/-- Two cone-neighbourhoods centred on the same vertex generate the same
`Affine.Cone.fan`s. -/
theorem cone_nhds_have_same_fans (cnhd0 cnhd1 : ConeNhd ğ•œ V P s) (hnhdv : cnhd0.vertex = cnhd1.vertex) :
    cnhd0.fan = cnhd1.fan := by
  -- It is sufficient to prove that one submodule is subset of the other by symmetry
  suffices hsub : (cn0' cn1' : ConeNhd ğ•œ V P s) â†’ (hv' : cn0'.vertex = cn1'.vertex) â†’
      cn0'.fan âŠ† cn1'.fan by
    exact eq_of_le_of_le (hsub cnhd0 cnhd1 hnhdv) (hsub cnhd1 cnhd0 hnhdv.symm)
  intro cn0 cn1 hv
  -- We can reduce to considering base points only
  suffices hbs : âˆ€ b : cn0.base, âˆƒ k : ğ•œ, 0 < k âˆ§ (cn0.lineMap b k) âˆˆ cn1.carrier by
    exact cn0.fan_le_fan cn1 hv hbs
  -- The rest follows from the continuity and neighbourhood properties
  rintro âŸ¨b, hbâŸ©

  admit

end Affine.ConeNhd

end Â«Tangent spacesÂ»
