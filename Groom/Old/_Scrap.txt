-- ********************************************************************
-- Do this stuff later
-- ********************************************************************

/- ---------- Contracted neighbourhood ----------------------------- -/

/-- Contracting a cone neighbourhood, i.e. dilating by a factor less
than `1`, yields a cone nighbourhood. Even though a contraction is a
homeomorphism, care must be taken because rescaling will not leave the
enclosing set invariant.

This theorem is relevant in the context of polyhedra, where it serves
to show that any neighbourhood of a point of a polyhedron contains a
cone-neighbourhood. -/
theorem contracted_is_coneNhd (cn : ConeNhd ğ•œ V P s) (hk : k âˆˆ Set.Ioo (0:ğ•œ) 1) :
    IsConeNhd ğ•œ V P (cn.contract hk) s where
  carrier_subset_of_set :=
    subset_trans (subset_trans (cn.contracted_subset_carrier_interior hk) (cn.carrier_interior_subset_carrier)) (cn.carrier_subset_of_set)
  carrier_is_closed := by
    have hc := (AffineMap.homothety_homeomorph_of_field cn.vertex (Set.Ioo_neq_0 hk)).isClosedMap cn.carrier cn.carrier_is_closed
    have h1 : AffineMap.homothety_homeomorph_of_field cn.vertex (Set.Ioo_neq_0 hk) '' cn.carrier = contract cn.toCone hk := by
      have h2 := congr_arg (fun f => f '' cn.carrier ) (AffineMap.homothety_homeomorph_of_field_toFun cn.vertex (Set.Ioo_neq_0 hk))
      dsimp at h2
      rw [h2, contract_carrier, contraction]
    rw [h1] at hc
    exact hc
    done
  carrier_interior_is_rel_open := by
    -- The carrier's interior of the contract is in the carrier's interior
    have hsub := subset_trans ((cn.contract hk).carrier_interior_subset_carrier) (cn.contracted_subset_carrier_interior hk)
    -- We only need to show that the carrier's inerior of the contract is open in the carrier's interior
    suffices hcioc : IsOpen $ rel[cn.carrier_interior] hsub by
      rcases (rel_open_iff_inter_with_open cn.carrier_interior_subset_of_set).mp cn.carrier_interior_is_rel_open with âŸ¨oci, hoci, hsociâŸ©
      rcases (rel_open_iff_inter_with_open hsub).mp hcioc with âŸ¨oci', hoci', hsoci'âŸ©
      rw [rel_open_iff_inter_with_open]
      use oci âˆ© oci'
      apply And.intro $ IsOpen.inter hoci hoci'
      rw [â†Set.inter_assoc, hsoci, hsoci']
      done
    rcases (rel_open_iff_inter_with_open cn.carrier_interior_subset_carrier).mp cn.carrier_interior_is_rel_open_in_carrier with âŸ¨o, âŸ¨hoo, hsociâŸ©âŸ©
    let o' := cn.contraction hk '' o
    have hoo' : IsOpen o' := (AffineMap.homothety_homeomorph_of_field cn.vertex (Set.Ioo_neq_0 hk)).isOpenMap o hoo
    rw [rel_open_iff_inter_with_open]
    use o'
    apply And.intro hoo'
    have hh:= cn.contraction_inter_comm hk (Eq.subset hsoci)
    rw [hsoci, â†contract_carrier_interior] at hh
    exact hh
    done

/-- Given a cone-neighbourhood, this provides the instance of a contracted
cone-neighbourhood. -/
def contracted (cn : ConeNhd ğ•œ V P s) (hk : k âˆˆ Set.Ioo (0:ğ•œ) 1) :
  ConeNhd ğ•œ V P s := cn.contracted_is_coneNhd hk

/-- Given another representation of a set which is provably equal to
the set of a given star-neighbourhood, the star-neighbourhood can also
be seen as a star-neighbourhood of the second set. -/
def to_eq_set (sn : StarNhd ğ•œ V P s) (hs : s = s') : StarNhd ğ•œ V P s' :=
 âŸ¨sn.toConeNhd.to_eq_set hs, sn.base_is_polyhedronâŸ©


/-- Contracting a cone neighbourhood, i.e. dilating by a factor less than `1`,
yields a cone nighbourhood. Even though a contraction is a homeomorphism,
care must be taken because rescaling will not leave the carrier set invariant.
The proof thus needs to show that the cone-neighbourhood can actually be
contracted within the carrier set. This requires that the ambient affine
space must have a topology that behaves suitably under rescaling which
is precisely the topology given by `Affine.PolyhedralSpace`.

This theorem is relevant in the context of polyhedra, where it serves to show
that any neighbourhood of a point of a polhyedron contains a cone-neighbourhood. -/
def contracted [Affine.PolyhedralSpace ğ•œ V P] (cn : ConeNhd ğ•œ V P s) (hk : k âˆˆ Set.Ioo (0:ğ•œ) 1) : ConeNhd ğ•œ V P s where
  vertex := cn.vertex
  base := (cn.contract hk).base
  vertex_not_in_base := by
    rw [â†cn.contract_fixes_vertex hk]
    exact (cn.contract hk).vertex_not_in_base
  lines_intersect_eq_base_points := by
    rw [â†cn.contract_fixes_vertex hk]
    exact (cn.contract hk).lines_intersect_eq_base_points
  carrier_subset_of_set := by
    exact subset_trans (subset_trans (cn.contracted_subset_carrier_interior hk) (cn.carrier_interior_subset_carrier)) (cn.carrier_subset_of_set)
  carrier_is_nhd := by
    rcases cn.carrier_interior_is_nhd__witness with âŸ¨u, âŸ¨hun, huscâŸ©âŸ©
    let cu := (cn.contraction hk) '' u
    have hcun : cu âˆˆ ğ“ cn.vertex := AffineMap.homothety_maps_nhds_of_vertex_to_nhds cn.vertex (Set.Ioo_01_neq_0 hk) hun
    have hcusc : cu âˆ© s âŠ† (cn.contract hk).carrier_interior := by

      admit
    exact âŸ¨cu, âŸ¨hcun, hcuscâŸ©âŸ©
  base_is_closed := by
    exact (Homeomorph.isClosedMap $ AffineMap.homothety_homeomorph_of_field cn.vertex (LT.lt.ne (Set.mem_Ioo.mp hk).left).symm) cn.base cn.base_is_closed


-- ********************************************************************
section Â«Cone raysÂ»

/-!
## Rays of cones

In this section we look at the rays defined by the vertex of an affine
cone and a base-point.
 -/

variable {ğ•œ : Type u} [LinearOrderedField ğ•œ]
variable {V : Type v} [AddCommGroup V] [Module ğ•œ V]
variable {P : Type w} [AddTorsor V P]

namespace Affine.Cone

/-- This maps each point different from the cone's vertex to its ray in ray-space. -/
def ray (c : Cone ğ•œ V P) (p : c.vertexC) : Module.Ray ğ•œ V :=
  RayVector.ray $ c.vector_to' p

/-- This maps each point different from the cone's vertex to its ray in ray-space. -/
def ray' (c : Cone ğ•œ V P) (hp : p â‰  c.vertex) : Module.Ray ğ•œ V :=
  RayVector.ray' (vsub_ne_zero.mpr hp)

/-- This maps a base-point to its ray in ray-space. -/
def rayb (c : Cone ğ•œ V P) (hb : b âˆˆ c.base) : Module.Ray ğ•œ V :=
  c.ray' (c.vertex_neq_base_point hb).symm

/-- The defintion of `ray_to` is independent of the cone used to define it. -/
theorem ray_to_independent_of_cone (c : Cone ğ•œ V P) (c' : Cone ğ•œ V P) (hv : c.vertex = c'.vertex) (hp : p â‰  c.vertex) :
    c.ray' hp = c'.ray' (hp âˆ˜ (fun x => Eq.trans x hv.symm)) := by
  unfold ray'
  rw [RayVector.ray', RayVector.ray_eq_iff_same_ray]
  simp only [vector_to_def]
  have hp' := hp âˆ˜ (fun x => Eq.trans x hv.symm)
  rw [ray_eq_iff (vsub_ne_zero.mpr hp) (vsub_ne_zero.mpr hp')]
  rw [hv]

/-- This is a restatement of `SameRay.ray_eq_iff`. -/
theorem ray_to_eq_iff_same_ray (c : Cone ğ•œ V P) (hpâ‚ : pâ‚ â‰  c.vertex) (hpâ‚‚ : pâ‚‚ â‰  c.vertex) :
    c.ray' hpâ‚ = c.ray' hpâ‚‚ â†” SameRay ğ•œ (c.vector_to pâ‚) (c.vector_to pâ‚‚) :=
  ray_eq_iff (vsub_ne_zero.mpr hpâ‚) (vsub_ne_zero.mpr hpâ‚‚)

/-- This is a restatement of `SameRay.exists_pos`. -/
theorem ray_to_eq_iff_exists_pos (c : Cone ğ•œ V P) (hpâ‚ : pâ‚ â‰  c.vertex) (hpâ‚‚ : pâ‚‚ â‰  c.vertex) :
    c.ray' hpâ‚ = c.ray' hpâ‚‚ â†” âˆƒ (k : ğ•œ), 0 < k âˆ§ k â€¢ (c.vector_to pâ‚) = c.vector_to pâ‚‚ := by
  apply Iff.intro
  Â· intro hreq; rw [ray_to_eq_iff_same_ray] at hreq
    rcases SameRay.exists_pos hreq (c.vector_to_vertexC_neq_0 hpâ‚) (c.vector_to_vertexC_neq_0 hpâ‚‚) with âŸ¨k1, âŸ¨k2, âŸ¨h0k1, âŸ¨h0k2, hk1k2âŸ©âŸ©âŸ©âŸ©
    use (k2â»Â¹ * k1)
    apply And.intro $ mul_pos (inv_pos.mpr h0k2) h0k1
    have hh := congr_arg (fun v : V => k2â»Â¹ â€¢ v) hk1k2; simp at hh; rw [smul_smul] at hh
    rw [hh, smul_smul, mul_comm, Field.mul_inv_cancel, one_smul]
    exact ne_of_gt h0k2
  Â· rintro âŸ¨k, âŸ¨h0k, hkvp1p2âŸ©âŸ©
    have hh : SameRay ğ•œ (c.vector_to pâ‚) (k â€¢ c.vector_to pâ‚):= SameRay.sameRay_pos_smul_right (c.vector_to pâ‚) h0k
    rw [hkvp1p2] at hh
    exact (c.ray_to_eq_iff_same_ray hpâ‚ hpâ‚‚).mpr hh

/-- This is a restatement of `SameRay.ray_eq_iff`. -/
theorem ray_to_eq_iff_same_ray' (c : Cone ğ•œ V P) (pâ‚ : c.vertexC) (pâ‚‚ : c.vertexC) :
    c.ray_to'' pâ‚ = c.ray_to'' pâ‚‚ â†” SameRay ğ•œ (c.vector_to pâ‚.val) (c.vector_to pâ‚‚.val) :=
  ray_eq_iff (vsub_ne_zero.mpr pâ‚.property) (vsub_ne_zero.mpr pâ‚‚.property)

/-- Different base points represent different rays. -/
theorem ray_to_base_point_unique (c : Cone ğ•œ V P) (hbâ‚ : bâ‚ âˆˆ c.base) (hbâ‚‚ : bâ‚‚ âˆˆ c.base) :
    bâ‚ = bâ‚‚ â†” SameRay ğ•œ (c.vector_to bâ‚) (c.vector_to bâ‚‚) := by
  have taux {bâ‚' bâ‚‚' : P} (hbâ‚' : bâ‚' âˆˆ c.base) (hbâ‚‚' : bâ‚‚' âˆˆ c.base) {k' : ğ•œ}
      (hk' : k' âˆˆ Set.Ioc (0:ğ•œ) 1) (h : k' â€¢ c.vector_to bâ‚' = c.vector_to bâ‚‚') : bâ‚' = bâ‚‚' := by
    have h1 := c.vector_to_eq_iff_points_eq.mp $ Eq.trans (c.vector_to_lineMap_k bâ‚' k') h
    have h2 : bâ‚‚' âˆˆ c.segmentOC hbâ‚' := by rw [â†lineMap_Ioc_to_segmentOC]; simp only [Set.mem_image]; use k'
    apply c.segmentOC_do_not_intersect hbâ‚' hbâ‚‚'
    have h3 := (Set.mem_inter_iff bâ‚‚' (c.segmentOC hbâ‚') (c.segmentOC hbâ‚‚')).mpr âŸ¨h2, c.base_point_in_segmentOC hbâ‚‚'âŸ©
    exact Set.not_empty_of_mem h3
  constructor
  Â· intro h; rw [h]
  Â· intro h
    rw [â†c.ray_to_eq_iff_same_ray (c.base_point_neq_vertex hbâ‚) (c.base_point_neq_vertex hbâ‚‚)] at h
    rw [c.ray_to_eq_iff_exists_pos (c.base_point_neq_vertex hbâ‚) (c.base_point_neq_vertex hbâ‚‚)] at h
    rcases h with âŸ¨k, âŸ¨h0k, hkvb1b2âŸ©âŸ©
    match lt_or_ge k 1 with
    | Or.inl hk1 => exact taux hbâ‚ hbâ‚‚ âŸ¨h0k, le_of_lt hk1âŸ© hkvb1b2
    | Or.inr h1k =>
      let hkvb1b2 := congr_arg (fun x : V => kâ»Â¹ â€¢ x) hkvb1b2
      simp at hkvb1b2; rw [smul_smul, mul_comm, Field.mul_inv_cancel, one_smul] at hkvb1b2
      have hk : kâ»Â¹ âˆˆ Set.Ioc (0:ğ•œ) 1 := by exact âŸ¨inv_pos.mpr h0k, inv_le_one h1kâŸ©
      exact (taux hbâ‚‚ hbâ‚ hk hkvb1b2.symm).symm
      exact ne_of_gt h0k

/-- This is a restatement of the property `ray_to_base_point_unique`. -/
theorem ray_to_injective_on_base (c : Cone ğ•œ V P) (hbâ‚ : bâ‚ âˆˆ c.base) (hbâ‚‚ : bâ‚‚ âˆˆ c.base) :
    c.ray' (c.base_point_neq_vertex hbâ‚) = c.ray' (c.base_point_neq_vertex hbâ‚‚) â†” bâ‚ = bâ‚‚ := by
  unfold ray'; rw [ray_eq_iff]; exact (c.ray_to_base_point_unique hbâ‚ hbâ‚‚).symm

/-- This is the set of rays running from the vertex to the base points. -/
def rays (c : Cone ğ•œ V P) : Set (Module.Ray ğ•œ V) := { r : Module.Ray ğ•œ V | âˆƒ b : c.base, c.rayb b.property = r }

/-- Rays through base points are in `rays`. -/
theorem ray_to_base_point_in_rays (c : Cone ğ•œ V P) (hb : b âˆˆ c.base) :
    c.ray' (c.base_point_neq_vertex hb) âˆˆ c.rays := by
  unfold rays; simp only [Set.mem_setOf]; use âŸ¨b, hbâŸ©; rfl

/-- Rays through base points are in `rays`. -/
theorem ray_to_base_point_in_rays' (c : Cone ğ•œ V P) (hb : b âˆˆ c.base) :
    c.rayb hb âˆˆ c.rays := by
  unfold rays; simp only [Set.mem_setOf]; use âŸ¨b, hbâŸ©

/-- Points in a segment from the vertex to a base point lie on the same ray
as the base point. -/
theorem point_on_lineMap_same_ray_as_base_point (c : Cone ğ•œ V P) (hb : b âˆˆ c.base) (h0k : (0:ğ•œ) < k) :
    c.ray' (c.lineMap_k_neq_vertex (c.base_point_neq_vertex hb) h0k) = c.rayb hb := by
  unfold rayb
  rw [c.ray_to_eq_iff_exists_pos (c.lineMap_k_neq_vertex (c.base_point_neq_vertex hb) h0k) (c.base_point_neq_vertex hb)]
  simp only [vector_to_lineMap_k]
  use kâ»Â¹
  apply And.intro $ inv_pos.mpr h0k
  rw [smul_smul, mul_comm, Field.mul_inv_cancel, one_smul]
  exact ne_of_gt h0k

/-- Points in the carrier of an affine cone define rays. -/
theorem point_in_carrier_defines_ray (c : Cone ğ•œ V P) (hpc : p âˆˆ c.carrier) (hpv : p â‰  c.vertex) :
    c.ray' hpv âˆˆ c.rays := by
  rcases c.point_in_carrier_on_lineMap hpc hpv with âŸ¨b, âŸ¨k, âŸ¨h0k, âŸ¨_, hlkpâŸ©âŸ©âŸ©âŸ©
  have hrr : c.ray' hpv = c.ray' (c.lineMap_k_neq_vertex (c.base_point_neq_vertex b.property) h0k) := by
    unfold ray_to; unfold vector_to; dsimp [lineMap, AffineMap.lineMap]; simp
    dsimp [lineMap, AffineMap.lineMap] at hlkp
    have x := congr_arg (fun q => q -áµ¥ c.vertex) hlkp; simp at x
    rw [ray_eq_iff, x]
  rw [hrr, c.point_on_lineMap_same_ray_as_base_point b.property h0k]
  exact c.ray_to_base_point_in_rays' b.property

end Affine.Cone

end Â«Cone raysÂ»

-- ********************************************************************
section Â«Topology of ray spacesÂ»

/-!
### Topology of ray spaces

Mathlib's implementation of the ray-package is unsatisfactory in several
ways:

- The main map used to map from vectors to rays is `Module.rayOfNeZero`
  which does not seem to conform the the usual naming conventions.
- The proof that the quotiont map is surjective apppeals to the axiom
  of choice, which is not necessary.

TODO.  -/

-- --------------------------------------------------------------------
section Â«DefinitionsÂ»

/-- Class `OpenSMul ğ•œ V` says that the scalar multiplication `(â€¢) : ğ•œ â†’ V â†’ V`
is an open map in the second argument whenever the scalar is non-zero. -/
class OpenSMul (ğ•œ : Type u) (V : Type v) [Zero ğ•œ] [SMul ğ•œ V] [TopologicalSpace V] : Prop where
  /-- The scalar multiplication `(â€¢)` is an open map. -/
  open_smul (_ : k â‰  (0:ğ•œ)) : IsOpenMap fun v : V => k â€¢ v

end Â«DefinitionsÂ»

-- --------------------------------------------------------------------
section Â«TopologyÂ»

variable {ğ•œ : Type u} [StrictOrderedCommSemiring ğ•œ]
variable {V : Type v} [AddCommMonoid V] [Module ğ•œ V]

namespace RayVector

/-- The map from non-zero vectors to rays. -/
def ray (v : RayVector ğ•œ V) : Module.Ray ğ•œ V := âŸ¦âŸ¨v, (Set.mem_setOf.mp v.property)âŸ©âŸ§

/-- The map from non-zero vectors to rays. -/
def ray' {v : V} (hv : v â‰  0) : Module.Ray ğ•œ V := ray âŸ¨v, hvâŸ©

/-- Two ray-vector map to the same value under `RayVector.ray` iff they
represent the same ray under `SameRay`. -/
theorem ray_eq_iff_same_ray
    {ğ•œ : Type u} [StrictOrderedCommSemiring ğ•œ]
    {V : Type v} [AddCommMonoid V] [Module ğ•œ V]
    (v : RayVector ğ•œ V) (w : RayVector ğ•œ V) :
    RayVector.ray v = RayVector.ray w â†” SameRay ğ•œ v.val w :=
  Quotient.eq'

/-- Two ray-vector map to the same value under `RayVector.ray` iff they
represent the same ray under `SameRay`. -/
theorem ray_eq_iff_same_ray'
    {ğ•œ : Type u} [StrictOrderedCommSemiring ğ•œ]
    {V : Type v} [AddCommMonoid V] [Module ğ•œ V]
    {v w : V} (hv : v â‰  0) (hw : w â‰  0) :
    RayVector.ray' hv = RayVector.ray' hw â†” SameRay ğ•œ v w :=
  Quotient.eq'

end RayVector

open RayVector

namespace Ray

/-- The map `ray` is surjective. -/
theorem ray_surjective :
    @Function.Surjective (RayVector ğ•œ V) (Module.Ray ğ•œ V) RayVector.ray := by
  exact surjective_quotient_mk (RayVector.Setoid ğ•œ V)

/-- The topology on the set of non-zero vectors is the induced topology. -/
instance topologicalSpace [topV: TopologicalSpace V]
    : TopologicalSpace (RayVector ğ•œ V) :=
  TopologicalSpace.induced (fun v => v.val) topV

/-- The topology of the ray-space is the quotient topology. -/
instance topology [TopologicalSpace V]
    : TopologicalSpace (Module.Ray ğ•œ V) := by
  apply @TopologicalSpace.coinduced (RayVector ğ•œ V) (Module.Ray ğ•œ V)
  exact ray
  exact topologicalSpace

/-- We note that `to_ray` is a quotient map. -/
theorem to_ray_quotient_map [TopologicalSpace V]
    : @QuotientMap (RayVector ğ•œ V) (Module.Ray ğ•œ V) topologicalSpace Ray.topology RayVector.ray := by
  apply And.intro ray_surjective; rfl

/-- The map `to_ray` is an open map provided scalar multiplication in the
module is an open map. -/
theorem to_ray_open_map
    [TopologicalSpace ğ•œ] [TopologicalSemiring ğ•œ]
    [TopologicalSpace V] [cSmul: ContinuousSMul ğ•œ V] [oSmul : OpenSMul ğ•œ V]
    : @IsOpenMap (RayVector ğ•œ V) (Module.Ray ğ•œ V) topologicalSpace Ray.topology RayVector.ray := by
  intro u hiou
  suffices huo : IsOpen $ RayVector.ray â»Â¹' (RayVector.ray '' u) by exact huo
  simp only [isOpen_induced_iff, Set.preimage, Set.image]
  let o := { v : V | âˆƒ w âˆˆ u, SameRay ğ•œ w.val v}
  use o
  apply And.intro
  Â· simp only [isOpen_induced_iff] at hiou; rcases hiou with âŸ¨u', âŸ¨hiou', _âŸ©âŸ©
    let I := { rs : ğ•œ Ã— ğ•œ // 0 < rs.1 âˆ§ 0 < rs.2 }
    let oi' (rs : I) := (fun x => rs.val.2 â€¢ x) '' u'
    let oi (rs : I) := (fun x : V => rs.val.1 â€¢ x) â»Â¹' (oi' rs)
    have hoio' (rs : I) : IsOpen (oi' rs) := (oSmul.open_smul (ne_of_gt rs.property.2)) u' hiou'
    have hci2 (rs : I) :  Continuous (fun x : V => rs.val.1 â€¢ x) := by
      admit
    have hoio (rs : I) : IsOpen (oi rs) := by exact Continuous.isOpen_preimage (hci2 rs) (oi' rs) (hoio' rs)
    have huinon : o = â‹ƒ (rs : I), oi rs := by
      ext v; apply Iff.intro
      Â· rintro âŸ¨w, âŸ¨hwu, hsrwvâŸ©âŸ©
        simp only [SameRay] at hsrwv
        admit
      Â· admit
    rw [huinon]
    exact isOpen_iUnion hoio
  Â· simp only [Set.mem_setOf, ray_eq_iff_same_ray, o]

end Ray

end Â«TopologyÂ»

-- ********************************************************************
section Â«Rays, tangent space, structureÂ»

variable {ğ•œ : Type u} [LinearOrderedField ğ•œ] [TopologicalSpace ğ•œ] [TopologicalRing ğ•œ] [OrderClosedTopology ğ•œ]
variable {V : Type v} [AddCommGroup V] [Module ğ•œ V] [TopologicalSpace V] [ContinuousAdd V] [ContinuousSMul ğ•œ V]
variable {P : Type w} [AddTorsor V P] [TopologicalSpace P] [TopologicalAddTorsor V P]

open Affine.Cone

namespace Affine.ConeNhd

/-- Auxiliary result to prove the theorem `cone_nhds_have_same_rays`. -/
private theorem cone_nhds_have_subset_rays (nhd1 : ConeNhd ğ•œ V P s) (nhd2 : ConeNhd ğ•œ V P s) :
    nhd1.rays âŠ† nhd2.rays := by

  -- Start with a ray of the first cone-neighbourhood
  -- intro r1 hr1
  -- simp only [ConeNhd.rays, Set.mem_setOf_eq] at hr1
  -- rcases hr1 with âŸ¨b1, h_rb1_eq_r1âŸ©
  -- -- Get a line segment for the ray
  -- let f : ğ•œ â†’áµƒ[ğ•œ] P := nhd1.lineMap b1.property
  -- have hfc0 : ContinuousAt f 0 := Continuous.continuous_at (nhd1.lineMap_continuous b1.property)
  -- have hf0v : f 0 = nhd1.vertex := by simp [AffineMap.lineMap_apply_zero]
  -- -- Find a point along the line that lies in the second cone neighbourhood
  -- rcases nhd2.is_rel_nhd with âŸ¨u, hunhd, hunhd2âŸ©
  -- have h_mem_u : nhd1.vertex âˆˆ u := by rwa â†hf0v at hunhd
  -- -- Use the fact that u is a neighborhood of the vertex to find a positive real number Îµ such that all points on the line segment [0, Îµ] are in u
  -- obtain âŸ¨Îµ, Îµ_pos, hÎµâŸ© : âˆƒ Îµ > 0, âˆ€ x, x âˆˆ Ioc 0 Îµ â†’ f x âˆˆ u :=
  --   exists_Ioc_subset_of_mem_nhds hunhd hfc0
  -- -- Use Îµ to construct a ray in the second neighborhood
  -- let b2 := âŸ¨f Îµ, by { rw [â†hf0v], apply hunhd2, use Îµ, split; try {linarith}, apply hÎµ, simp }âŸ©
  -- -- Show that this ray corresponds to the original ray in the first neighborhood, completing the proof
  -- use b2
  -- simp only [h_rb1_eq_r1, h_rb1_eq_r1.symm, AffineMap.lineMap_apply_module']
  -- exact âŸ¨Îµ, Îµ_pos, by simpâŸ©
  -- done

  -- Start with a ray of the first cone-neighbourghood
  --intro r1 hr1
  -- simp only [Cone.rays, Set.mem_setOf] at hr1
  -- rcases hr1 with âŸ¨b1, h_rb1_eq_r1âŸ©
  -- -- Get a line segment for the ray
  -- let f : ğ•œ â†’áµƒ[ğ•œ] P := nhd1.lineMap b1.property
  -- have hfc0 : ContinuousAt f (0:ğ•œ) := Continuous.continuousAt Affine.lineMap_continuous
  -- have hf0v : f (0:ğ•œ) = nhd2.vertex := by simp only [â†heqv, f, Cone.lineMap, AffineMap.lineMap_apply_zero]
  -- -- Find a point along the line that lies in the second cone neighbourhood
  -- rcases nhd2.is_rel_nhd with âŸ¨u, âŸ¨hunhd, hunhd2âŸ©âŸ©
  -- rw [â†hf0v] at hunhd
  -- rcases Ring.exists_elements_close_to_zero_for_map ndtR f hfc0 1 zero_lt_one u hunhd with âŸ¨k, âŸ¨h0k, âŸ¨hk1, hfkuâŸ©âŸ©âŸ©
  -- have hkIoo : k âˆˆ Ioo (0:ğ•œ) 1 := Set.mem_Ioo.mpr âŸ¨h0k, hk1âŸ©
  -- have hkIcc : k âˆˆ Icc (0:ğ•œ) 1 := Set.Ioo_subset_Icc_self hkIoo
  -- -- The point is found, now show it lies in the right sets
  -- have hfknhd1 : f k âˆˆ nhd1.carrier := nhd1.lineMap_maps_to_carrier b1.property hkIcc
  -- have h_fk_neq_v1 : f k â‰  nhd1.vertex := nhd1.lineMap_k_neq_vertex b1.property h0k
  -- have hfks : f k âˆˆ s := nhd1.subset_set hfknhd1
  -- have hfknhd2 : f k âˆˆ nhd2.carrier := mem_of_mem_of_subset (mem_inter hfku hfks) hunhd2
  -- have h_fk_neq_v2 : f k â‰  nhd2.vertex := by rw [â†heqv]; exact h_fk_neq_v1
  -- -- Now argue with rays
  -- have h_rfk_eq_rb1 := nhd1.point_on_lineMap_same_ray_as_base_point b1.property h0k
  -- have h_r1_eq_rfk := Eq.trans h_rb1_eq_r1.symm h_rfk_eq_rb1.symm
  -- have h_rfk_nhd1_nhd2 := nhd1.ray_to_independent_of_cone nhd2 heqv h_fk_neq_v1
  -- let r2 := nhd2.ray_to h_fk_neq_v2
  -- have hr2inr2 := nhd2.point_in_carrier_defines_ray hfknhd2 h_fk_neq_v2
  admit

/-- Two cone-neighbourhoods centred on the same vertex have identical rays. -/
theorem cone_nhds_have_same_rays (nhd1 : ConeNhd ğ•œ V P s) (nhd2 : ConeNhd ğ•œ V P s) :
    nhd1.rays = nhd2.rays :=
  Set.eq_of_subset_of_subset (cone_nhds_have_subset_rays nhd1 nhd2 ) (cone_nhds_have_subset_rays nhd2 nhd1)

-- --------------------------------------------------------------------

/--
TODO Define the tangent-rays of a ConeNhd and show that this is a closed set. -/
example : 1=1 := rfl

/--
TODO Define the tangent-space of a ConeNhd and show that this is a closed set. -/
example : 1=1 := rfl

/--
TODO Can we show some upper semicontiuity for the tangent space? Move this to polyhedra section. -/
example : 1=1 := rfl

end Affine.ConeNhd

end Â«Rays, tangent space, structureÂ»


-- ********************************************************************

-- ********************************************************************